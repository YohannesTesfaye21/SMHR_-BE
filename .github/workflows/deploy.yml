name: Deploy

on:
  workflow_run:
    workflows: ["CI - Build and Test"]
    branches:
      - main
      - master
    types:
      - completed
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.0.0
        env:
          DB_PASSWORD: ${{ secrets.DB_PASSWORD || 'postgres' }}
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            set -e
            
            APP_DIR="/opt/smhfr-be"
            REPO_URL="https://github.com/YohannesTesfaye21/SMHR_-BE.git"
            
            # Ensure Docker is installed
            if ! command -v docker &> /dev/null; then
              echo "Installing Docker..."
              curl -fsSL https://get.docker.com | sh
              systemctl enable docker
              systemctl start docker
            fi
            
            # Ensure Git is installed
            command -v git &> /dev/null || (apt-get update && apt-get install -y git)
            
            # Create application directory
            mkdir -p "$APP_DIR"
            cd "$APP_DIR"
            
            # Clone or update repository
            if [ -d ".git" ]; then
              echo "Pulling latest changes..."
              git fetch origin
              git reset --hard origin/main
            else
              echo "Cloning repository..."
              git clone "$REPO_URL" .
            fi
            
            # Ensure docker-compose.yml exists
            if [ ! -f "docker-compose.yml" ]; then
              echo "Error: docker-compose.yml not found!"
              exit 1
            fi
            
            # Set database password from GitHub secret or use default
            export DB_PASSWORD="${DB_PASSWORD:-postgres}"
            echo "Using DB_PASSWORD from environment (from GitHub secret)"
            echo "DB_PASSWORD value is set (length: ${#DB_PASSWORD} characters)"
            
            # Create .env file for docker-compose to use
            echo "DB_PASSWORD=$DB_PASSWORD" > .env
            echo "Created .env file with DB_PASSWORD"
            
            # Also set the connection string directly as environment variable for API
            # Docker Compose may not substitute variables inside environment variable values
            export CONNECTION_STRING="Host=postgres;Port=5432;Database=smhfr_db;Username=postgres;Password=$DB_PASSWORD;Pooling=true;Minimum Pool Size=0;Maximum Pool Size=100;Connection Lifetime=300;Command Timeout=30;SSL Mode=Disable"
            
            # Build new image
            echo "Building Docker image..."
            docker compose build --no-cache api
            
            # Start PostgreSQL first (preserves data)
            echo "Ensuring PostgreSQL is running..."
            DB_PASSWORD="$DB_PASSWORD" docker compose up -d postgres
            
            # Wait for PostgreSQL to be healthy
            echo "Waiting for PostgreSQL..."
            timeout 60 bash -c 'until docker compose exec -T postgres pg_isready -U postgres; do sleep 2; done' || {
              echo "PostgreSQL not ready, checking logs..."
              docker compose logs postgres --tail=50
              exit 1
            }
            
            # Verify database connection and fix password if needed
            echo "Verifying database connection..."
            sleep 3
            
            # Test connection with password from GitHub secret
            if PGPASSWORD="$DB_PASSWORD" docker compose exec -T -e PGPASSWORD="$DB_PASSWORD" postgres psql -U postgres -d smhfr_db -c "SELECT 1;" > /dev/null 2>&1; then
              echo "✅ Database connection successful with password from GitHub secret"
            else
              echo "⚠️  Database connection failed. Attempting to reset password using local socket..."
              echo "DB_PASSWORD from GitHub secret is being used"
              
              # Reset password using Unix socket (local connection, no password required)
              # This works because we removed POSTGRES_HOST_AUTH_METHOD, allowing local trust auth
              if docker compose exec -T postgres psql -U postgres -d postgres -c "ALTER USER postgres WITH PASSWORD '$DB_PASSWORD';" 2>/dev/null; then
                echo "✅ Password reset successful to value from GitHub secret"
                sleep 2
                
                # Test connection again with new password
                if PGPASSWORD="$DB_PASSWORD" docker compose exec -T -e PGPASSWORD="$DB_PASSWORD" postgres psql -U postgres -d smhfr_db -c "SELECT 1;" > /dev/null 2>&1; then
                  echo "✅ Database connection successful after password reset"
                else
                  echo "❌ Database connection still failing after password reset!"
                  echo "DB_PASSWORD from secret might be incorrect or PostgreSQL volume has different password"
                  docker compose logs postgres --tail=30
                  exit 1
                fi
              else
                echo "❌ Could not reset password. The PostgreSQL volume may need to be recreated."
                echo ""
                echo "DB_PASSWORD from GitHub secret is being used"
                echo ""
                echo "To fix (WARNING: deletes all data):"
                echo "  docker compose down -v"
                echo "  DB_PASSWORD='$DB_PASSWORD' docker compose up -d"
                echo ""
                docker compose logs postgres --tail=30
                exit 1
              fi
            fi
            
            # Stop old API container (zero-downtime: new container will be up before old one stops)
            echo "Updating API service..."
            echo "Starting API with DB_PASSWORD from environment..."
            
            # Use docker compose up with environment variable override
            # Docker Compose will read .env file and substitute ${DB_PASSWORD}
            DB_PASSWORD="$DB_PASSWORD" docker compose up -d --no-deps --build api
            
            # Wait a moment for container to start
            sleep 3
            
            # Verify the connection string was substituted correctly (check it doesn't contain ${DB_PASSWORD})
            echo "Verifying API container connection string..."
            if docker compose exec api printenv ConnectionStrings__DefaultConnection 2>/dev/null | grep -q '\${DB_PASSWORD}'; then
              echo "❌ ERROR: Connection string still contains \${DB_PASSWORD} - variable substitution failed!"
              echo "Connection string value:"
              docker compose exec api printenv ConnectionStrings__DefaultConnection
              exit 1
            else
              echo "✅ Connection string variable substitution verified"
            fi
            
            # Wait for new API to be healthy
            echo "Waiting for API to be healthy..."
            timeout 60 bash -c 'until curl -f http://localhost:8080/api/health > /dev/null 2>&1; do sleep 2; done' || {
              echo "❌ API health check failed, checking logs..."
              echo "=== Full API Logs (last 100 lines) ==="
              docker compose logs api --tail=100
              echo ""
              echo "=== Checking container status ==="
              docker compose ps
              echo ""
              echo "=== Checking if API can reach PostgreSQL ==="
              docker compose exec api sh -c "timeout 5 sh -c 'until nc -z postgres 5432; do sleep 1; done' && echo 'PostgreSQL port is reachable' || echo 'Cannot reach postgres:5432'" 2>&1 || echo "Network check failed"
              echo ""
              echo "=== Checking API container network ==="
              docker compose exec api cat /etc/hosts | grep postgres || echo "PostgreSQL hostname not in /etc/hosts"
              exit 1
            }
            
            # Remove old/stopped containers
            docker container prune -f
            
            # Verify deployment
            echo "Verifying deployment..."
            docker compose ps
            curl -f http://localhost:8080/api/health && echo "✅ Deployment successful!"
            
            # Clean up old images
            docker image prune -f
