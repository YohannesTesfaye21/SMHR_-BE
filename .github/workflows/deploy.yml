name: Deploy

on:
  workflow_run:
    workflows: ["CI - Build and Test"]
    types:
      - completed
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 3
    if: github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Copy files to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          source: "."
          target: "/opt/smhfr-be"
          overwrite: true
          rm: false
          strip_components: 0
          exclude: |
            .git
            .github
            **/bin
            **/obj
            **/.vs
            **/.vscode
            *.md
            SERVER_FAILURE_ANALYSIS.md

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            cd /opt/smhfr-be
            export COMPOSE_PROJECT_NAME=smhfr-be
            
            # Create .env file
            cat > .env <<EOF
            DB_HOST=postgres
            DB_PORT=5432
            DB_NAME=smhfr_db
            DB_USER=postgres
            DB_PASSWORD=${{ secrets.DB_PASSWORD }}
            EOF
            
            # Ensure entrypoint script is executable
            chmod +x docker-entrypoint-postgres.sh
            
            # Stop and recreate postgres to ensure entrypoint script runs
            echo "üîÑ Restarting Postgres to trigger entrypoint script..."
            docker compose --env-file .env stop postgres 2>/dev/null || true
            docker compose --env-file .env up -d postgres
            
            # Wait for Postgres to be ready (entrypoint script will sync password)
            echo "‚è≥ Waiting for Postgres and password sync..."
            for i in {1..30}; do
              if docker compose exec -T postgres pg_isready -U postgres > /dev/null 2>&1; then
                echo "‚úÖ Postgres is ready"
                # Check if entrypoint script has synced password by checking logs
                if docker compose logs postgres 2>/dev/null | grep -q "Password synchronized successfully\|Current password already matches"; then
                  echo "‚úÖ Password sync confirmed from entrypoint script"
                  break
                elif [ $i -ge 10 ]; then
                  # After 10 seconds, try to verify password anyway
                  echo "‚è≥ Entrypoint script may still be syncing, verifying password..."
                  break
                fi
              fi
              sleep 1
            done
            
            # Wait a bit more for entrypoint script to complete
            sleep 3
            
            # Verify password works (entrypoint script should have synced it)
            echo "üîç Verifying password after entrypoint sync..."
            PGPASSWORD='${{ secrets.DB_PASSWORD }}' docker compose exec -T -e PGPASSWORD='${{ secrets.DB_PASSWORD }}' postgres psql -h localhost -U postgres -d postgres -c "SELECT 1;" > /dev/null 2>&1
            if [ $? -ne 0 ]; then
              echo "‚ö†Ô∏è  Password verification failed, checking entrypoint script logs..."
              docker compose logs postgres | tail -20
              echo "üîÑ Attempting manual password sync as fallback..."
              docker compose exec -T postgres psql -U postgres -d postgres -c "ALTER USER postgres WITH PASSWORD '${{ secrets.DB_PASSWORD }}';" || true
              sleep 2
              # Verify again
              PGPASSWORD='${{ secrets.DB_PASSWORD }}' docker compose exec -T -e PGPASSWORD='${{ secrets.DB_PASSWORD }}' postgres psql -h localhost -U postgres -d postgres -c "SELECT 1;" > /dev/null 2>&1
              if [ $? -ne 0 ]; then
                echo "‚ùå Password verification failed even after manual sync"
                exit 1
              fi
            fi
            echo "‚úÖ Password verified"
            
            # Stop API before running migrations
            docker compose stop api 2>/dev/null || true
            
            # Run database migrations explicitly in CI/CD pipeline
            echo "üîÑ Running database migrations..."
            # Remove any persisted connection string file to ensure environment variable is used
            rm -f data/.connectionstring 2>/dev/null || true
            # Docker Compose creates network as: {project_name}_{network_name}
            # Project name is set to "smhfr-be" above, network is "smhfr-network"
            # So full network name is: smhfr-be_smhfr-network
            # Use SDK image to run migrations (has EF tools available)
            docker run --rm \
              --network smhfr-be_smhfr-network \
              -v $(pwd):/src \
              -w /src \
              mcr.microsoft.com/dotnet/sdk:8.0 \
              sh -c "rm -f /src/data/.connectionstring 2>/dev/null || true && export PATH=\"\$PATH:/root/.dotnet/tools\" && dotnet tool install --global dotnet-ef && dotnet restore SMHFR_BE.csproj && export ConnectionStrings__DefaultConnection='Host=postgres;Port=5432;Database=smhfr_db;Username=postgres;Password=${{ secrets.DB_PASSWORD }};Pooling=true;Minimum Pool Size=0;Maximum Pool Size=100;Command Timeout=30;Keepalive=30;Tcp Keepalive=true;SSL Mode=Disable' && dotnet ef database update --project SMHFR_BE.csproj --verbose" || {
                echo "‚ùå Migration failed!"
                echo "üìã Checking current database schema..."
                docker compose exec -T postgres psql -U postgres -d smhfr_db -c "\d \"HealthFacilities\"" || true
                exit 1
              }
            echo "‚úÖ Migrations completed successfully"
            
            # Verify critical tables exist (check for OperationalStatuses and Ownerships tables)
            echo "üîç Verifying critical tables exist..."
            # Check in public schema specifically (EF Core uses public schema by default)
            CHECK_STATUSES=$(docker compose exec -T postgres psql -U postgres -d smhfr_db -t -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'OperationalStatuses';" 2>/dev/null | tr -d '[:space:]' || echo "0")
            CHECK_OWNERSHIPS=$(docker compose exec -T postgres psql -U postgres -d smhfr_db -t -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Ownerships';" 2>/dev/null | tr -d '[:space:]' || echo "0")
            
            if [ "$CHECK_STATUSES" != "1" ] || [ "$CHECK_OWNERSHIPS" != "1" ]; then
              echo "‚ö†Ô∏è  Critical lookup tables missing! (OperationalStatuses: $CHECK_STATUSES, Ownerships: $CHECK_OWNERSHIPS)"
              echo "üîÑ Tables missing - migration may not have been applied. Diagnosing issue..."
              
              # List all migrations in history for debugging
              echo "üìã Current migration history:"
              docker compose exec -T postgres psql -U postgres -d smhfr_db -c "SELECT \"MigrationId\", \"ProductVersion\" FROM \"__EFMigrationsHistory\" ORDER BY \"MigrationId\";" 2>/dev/null || true
              
              # Check what EF Core thinks needs to be applied
              echo "üîç Checking what EF Core detects as pending migrations..."
              rm -f data/.connectionstring 2>/dev/null || true
              PENDING_MIGRATIONS=$(docker run --rm \
                --network smhfr-be_smhfr-network \
                -v $(pwd):/src \
                -w /src \
                mcr.microsoft.com/dotnet/sdk:8.0 \
                sh -c "rm -f /src/data/.connectionstring 2>/dev/null || true && export PATH=\"\$PATH:/root/.dotnet/tools\" && dotnet tool install --global dotnet-ef > /dev/null 2>&1 && dotnet restore SMHFR_BE.csproj > /dev/null 2>&1 && export ConnectionStrings__DefaultConnection='Host=postgres;Port=5432;Database=smhfr_db;Username=postgres;Password=${{ secrets.DB_PASSWORD }};Pooling=true;Minimum Pool Size=0;Maximum Pool Size=100;Command Timeout=30;Keepalive=30;Tcp Keepalive=true;SSL Mode=Disable' && dotnet ef migrations list --project SMHFR_BE.csproj 2>&1" || echo "ERROR")
              
              echo "$PENDING_MIGRATIONS"
              
              # Check if the specific migration is in history
              MIGRATION_EXISTS=$(docker compose exec -T postgres psql -U postgres -d smhfr_db -t -c "SELECT COUNT(*) FROM \"__EFMigrationsHistory\" WHERE \"MigrationId\" = '20260123184530_ConvertOwnershipAndOperationalStatusToLookupTables';" 2>/dev/null | tr -d '[:space:]' || echo "0")
              
              if [ "$MIGRATION_EXISTS" = "1" ]; then
                echo "‚ö†Ô∏è  Migration entry exists in history but tables are missing - this indicates a failed/partial migration"
                echo "üîÑ Removing migration entry and forcing re-application..."
                # Remove the migration history entry so EF Core will re-apply it
                docker compose exec -T postgres psql -U postgres -d smhfr_db -c "DELETE FROM \"__EFMigrationsHistory\" WHERE \"MigrationId\" = '20260123184530_ConvertOwnershipAndOperationalStatusToLookupTables';" 2>/dev/null || true
              else
                echo "‚ÑπÔ∏è  Migration entry not in history - checking if we can force apply it..."
                # Check if HealthFacilities table has the old columns (OperationalStatus, Ownership) or new ones (OperationalStatusId, OwnershipId)
                HAS_OLD_COLS=$(docker compose exec -T postgres psql -U postgres -d smhfr_db -t -c "SELECT COUNT(*) FROM information_schema.columns WHERE table_name = 'HealthFacilities' AND column_name IN ('OperationalStatus', 'Ownership');" 2>/dev/null | tr -d '[:space:]' || echo "0")
                HAS_NEW_COLS=$(docker compose exec -T postgres psql -U postgres -d smhfr_db -t -c "SELECT COUNT(*) FROM information_schema.columns WHERE table_name = 'HealthFacilities' AND column_name IN ('OperationalStatusId', 'OwnershipId');" 2>/dev/null | tr -d '[:space:]' || echo "0")
                
                echo "   HealthFacilities has old columns (OperationalStatus/Ownership): $HAS_OLD_COLS"
                echo "   HealthFacilities has new columns (OperationalStatusId/OwnershipId): $HAS_NEW_COLS"
                
                # If we have old columns but not new ones, the migration hasn't been applied at all
                # If we have new columns, something is very wrong (tables should exist)
                if [ "$HAS_OLD_COLS" = "2" ] && [ "$HAS_NEW_COLS" = "0" ]; then
                  echo "‚úÖ Database is in pre-migration state - migration should apply cleanly"
                elif [ "$HAS_NEW_COLS" = "2" ]; then
                  echo "‚ö†Ô∏è  Database has new columns but lookup tables are missing - this is inconsistent state"
                  echo "üîÑ This suggests a partial migration. Attempting to create tables manually..."
                  # Try to create the tables manually if they're missing but columns exist
                  docker compose exec -T postgres psql -U postgres -d smhfr_db <<'EOSQL'
CREATE TABLE IF NOT EXISTS "OperationalStatuses" (
    "OperationalStatusId" SERIAL PRIMARY KEY,
    "StatusName" VARCHAR(50) NOT NULL,
    "CreatedAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);
CREATE UNIQUE INDEX IF NOT EXISTS "IX_OperationalStatuses_StatusName" ON "OperationalStatuses" ("StatusName");

CREATE TABLE IF NOT EXISTS "Ownerships" (
    "OwnershipId" SERIAL PRIMARY KEY,
    "OwnershipType" VARCHAR(50) NOT NULL,
    "CreatedAt" TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
);
CREATE UNIQUE INDEX IF NOT EXISTS "IX_Ownerships_OwnershipType" ON "Ownerships" ("OwnershipType");
EOSQL
                  # Now mark the migration as applied
                  docker compose exec -T postgres psql -U postgres -d smhfr_db -c "INSERT INTO \"__EFMigrationsHistory\" (\"MigrationId\", \"ProductVersion\") VALUES ('20260123184530_ConvertOwnershipAndOperationalStatusToLookupTables', '8.0.0') ON CONFLICT DO NOTHING;" 2>/dev/null || true
                fi
              fi
              
              # Re-run migrations - EF Core will detect the missing migration and apply it
              echo "üîÑ Re-running migrations to apply missing migration..."
              # Remove persisted connection string file to ensure environment variable is used
              rm -f data/.connectionstring 2>/dev/null || true
              docker run --rm \
                --network smhfr-be_smhfr-network \
                -v $(pwd):/src \
                -w /src \
                mcr.microsoft.com/dotnet/sdk:8.0 \
                sh -c "rm -f /src/data/.connectionstring 2>/dev/null || true && export PATH=\"\$PATH:/root/.dotnet/tools\" && dotnet tool install --global dotnet-ef > /dev/null 2>&1 && dotnet restore SMHFR_BE.csproj > /dev/null 2>&1 && export ConnectionStrings__DefaultConnection='Host=postgres;Port=5432;Database=smhfr_db;Username=postgres;Password=${{ secrets.DB_PASSWORD }};Pooling=true;Minimum Pool Size=0;Maximum Pool Size=100;Command Timeout=30;Keepalive=30;Tcp Keepalive=true;SSL Mode=Disable' && dotnet ef database update --project SMHFR_BE.csproj" || {
                  echo "‚ùå Re-application failed!"
                  echo "üìã Checking database state..."
                  docker compose exec -T postgres psql -U postgres -d smhfr_db -c "\d \"HealthFacilities\"" || true
                  exit 1
                }
              
              # Verify again
              CHECK_STATUSES_AFTER=$(docker compose exec -T postgres psql -U postgres -d smhfr_db -t -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'OperationalStatuses';" 2>/dev/null | tr -d '[:space:]' || echo "0")
              CHECK_OWNERSHIPS_AFTER=$(docker compose exec -T postgres psql -U postgres -d smhfr_db -t -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'Ownerships';" 2>/dev/null | tr -d '[:space:]' || echo "0")
              if [ "$CHECK_STATUSES_AFTER" = "1" ] && [ "$CHECK_OWNERSHIPS_AFTER" = "1" ]; then
                echo "‚úÖ Both lookup tables now exist"
              else
                echo "‚ùå Tables still missing after re-application! (OperationalStatuses: $CHECK_STATUSES_AFTER, Ownerships: $CHECK_OWNERSHIPS_AFTER)"
                echo "üìã Final database state check:"
                docker compose exec -T postgres psql -U postgres -d smhfr_db -c "SELECT \"MigrationId\" FROM \"__EFMigrationsHistory\" ORDER BY \"MigrationId\";" || true
                exit 1
              fi
            else
              echo "‚úÖ Both OperationalStatuses and Ownerships tables exist"
            fi
            
            # Remove persisted connection string volume
            docker volume rm smhfr-be_api_data 2>/dev/null || true
            
            # Start API
            echo "üöÄ Starting API..."
            docker compose --env-file .env up -d --no-deps api
            
            # Wait for API container to be running and accessible (max 60 seconds)
            echo "‚è≥ Waiting for API to start and become accessible..."
            for i in {1..30}; do
              if docker compose ps api | grep -q "Up"; then
                echo "‚úÖ API container is running"
                # Give it a moment to initialize
                sleep 5
                # Check if it's still running (didn't crash)
                if docker compose ps api | grep -q "Up"; then
                  # Try to access the health endpoint
                  echo "üîç Testing API accessibility..."
                  if curl -f -s http://localhost:8080/api/health > /dev/null 2>&1; then
                    echo "‚úÖ API is accessible via HTTP"
                    # Verify migrations ran successfully
                    echo "üîç Verifying database migrations..."
                    sleep 3  # Give migrations more time to complete
                    if docker compose logs api 2>/dev/null | grep -q "Database migrations applied successfully"; then
                      echo "‚úÖ Database migrations applied successfully"
                    else
                      echo "‚ö†Ô∏è  Could not confirm migrations in logs, checking for errors..."
                      # Check for migration-related errors
                      if docker compose logs api 2>/dev/null | grep -qi "Failed to apply\|Migration failed\|Failed to initialize database"; then
                        echo "‚ùå Migration errors detected in logs!"
                        echo "üìã Full migration-related logs:"
                        docker compose logs api | grep -i -A 10 -B 5 "migration\|Migration\|initialize\|Initialize" | tail -50
                        echo "‚ö†Ô∏è  API is running but migrations may have failed. Check logs above."
                        echo "üí° You can manually trigger migrations via: POST /api/health/migrate"
                      else
                        echo "‚ö†Ô∏è  Migration status unclear - checking if migration already applied..."
                        # Check if new columns exist (migration already applied)
                        if docker compose exec -T postgres psql -U postgres -d smhfr_db -c "\d \"HealthFacilities\"" 2>/dev/null | grep -q "OperationalStatusId"; then
                          echo "‚úÖ Migration appears to be applied (OperationalStatusId column exists)"
                        else
                          echo "‚ö†Ô∏è  Migration may not be applied. Check API logs for details."
                          docker compose logs api | tail -30
                        fi
                      fi
                    fi
                    # Try Swagger endpoint
                    if curl -f -s http://localhost:8080/swagger/index.html > /dev/null 2>&1; then
                      echo "‚úÖ Swagger UI is accessible"
                    else
                      echo "‚ö†Ô∏è  Swagger UI not accessible, but API is running"
                    fi
                    echo "‚úÖ Deployment successful"
                    # Check HTTPS configuration
                    echo "üîç Checking HTTPS configuration..."
                    docker compose logs api | grep -E "(HTTPS|Certificate|cert|Listening)" | tail -10 || echo "No HTTPS logs found"
                    # Show recent logs
                    echo "üìã Recent API logs:"
                    docker compose logs api --tail=20
                    exit 0
                  else
                    echo "‚ö†Ô∏è  API container is running but not responding (attempt $i/30)"
                    if [ $i -ge 10 ]; then
                      echo "üìã API logs:"
                      docker compose logs api --tail=30
                    fi
                  fi
                else
                  echo "‚ùå API container crashed after startup"
                  docker compose logs api --tail=50
                  exit 1
                fi
              fi
              echo "‚è≥ Waiting for API... (attempt $i/30)"
              sleep 2
            done
            
            # Final check
            if docker compose ps api | grep -q "Up"; then
              echo "‚ö†Ô∏è  API container is running but not accessible after 60 seconds"
              echo "üìã Checking logs and container status:"
              docker compose ps api
              docker compose logs api --tail=50
              echo "üîç Testing connectivity:"
              curl -v http://localhost:8080/api/health || echo "Connection failed"
              exit 1
            else
              echo "‚ùå API not running after 60 seconds"
              docker compose logs api --tail=50
              exit 1
            fi
