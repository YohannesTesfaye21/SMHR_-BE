name: Deploy

on:
  workflow_run:
    workflows: ["CI - Build and Test"]
    branches:
      - main
      - master
    types:
      - completed
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.0.0
        env:
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          envs: DB_PASSWORD
          script: |
            set -e
            
            APP_DIR="/opt/smhfr-be"
            REPO_URL="https://github.com/YohannesTesfaye21/SMHR_-BE.git"
            
            # Ensure Docker is installed
            if ! command -v docker &> /dev/null; then
              echo "Installing Docker..."
              curl -fsSL https://get.docker.com | sh
              systemctl enable docker
              systemctl start docker
            fi
            
            # Ensure Git is installed
            command -v git &> /dev/null || (apt-get update && apt-get install -y git)
            
            # Create application directory
            mkdir -p "$APP_DIR"
            cd "$APP_DIR"
            
            # Clone or update repository
            if [ -d ".git" ]; then
              echo "Pulling latest changes..."
              git fetch origin
              git reset --hard origin/main
            else
              echo "Cloning repository..."
              git clone "$REPO_URL" .
            fi
            
            # Ensure docker-compose.yml exists
            if [ ! -f "docker-compose.yml" ]; then
              echo "Error: docker-compose.yml not found!"
              exit 1
            fi
            
            # Set database password from GitHub secret (REQUIRED - no default)
            if [ -z "$DB_PASSWORD" ]; then
              echo "❌ ERROR: DB_PASSWORD environment variable is not set!"
              echo "Please set DB_PASSWORD in GitHub secrets"
              exit 1
            fi
            echo "Using DB_PASSWORD from environment (from GitHub secret)"
            echo "DB_PASSWORD value is set (length: ${#DB_PASSWORD} characters)"
            
            # Create/update .env file on server - MUST be in same directory as docker-compose.yml
            # This file will persist on the server and be used by docker-compose
            echo "Creating/updating .env file on server..."
            echo "DB_PASSWORD=$DB_PASSWORD" > .env
            echo "✅ Created .env file"
            echo "Current directory: $(pwd)"
            echo ".env file location: $(pwd)/.env"
            echo ".env file exists: $([ -f .env ] && echo 'yes' || echo 'no')"
            echo ".env file permissions: $(ls -la .env 2>/dev/null || echo 'not found')"
            
            # Verify .env file contents (password hidden)
            echo "Verifying .env file contents..."
            if grep -q "DB_PASSWORD=" .env; then
              echo "✅ .env file contains DB_PASSWORD"
            else
              echo "❌ ERROR: .env file does not contain DB_PASSWORD!"
              exit 1
            fi
            
            # Export to environment AND source .env file to ensure variables are available
            export DB_PASSWORD
            set -a  # Automatically export all variables
            source .env
            set +a
            echo "✅ Exported DB_PASSWORD to environment (length: ${#DB_PASSWORD} characters)"
            
            # Build new image
            echo "Building Docker image..."
            docker compose build --no-cache api
            
            # Stop containers and remove volume to ensure fresh start with correct password
            echo "Stopping containers and removing volume..."
            docker compose down 2>/dev/null || true
            POSTGRES_VOLUME=$(docker volume ls -q | grep -E "(postgres_data|smhfr.*postgres)" | head -1 || echo "")
            if [ -n "$POSTGRES_VOLUME" ]; then
              docker volume rm "$POSTGRES_VOLUME" 2>/dev/null || true
            fi
            
            # Start PostgreSQL with correct password from .env file
            echo "Starting PostgreSQL with .env file..."
            # Ensure .env file exists and is readable
            if [ ! -f .env ]; then
              echo "❌ ERROR: .env file not found!"
              exit 1
            fi
            # Use --env-file to explicitly load .env file
            docker compose --env-file .env up -d postgres
            
            # Wait for PostgreSQL to be ready
            echo "Waiting for PostgreSQL..."
            for i in {1..30}; do
              if docker compose exec -T postgres pg_isready -U postgres > /dev/null 2>&1; then
                echo "✅ PostgreSQL is ready"
                break
              fi
              if [ $i -eq 30 ]; then
                echo "❌ PostgreSQL failed to start"
                docker compose logs postgres --tail=50
                exit 1
              fi
              sleep 2
            done
            
            # Verify PostgreSQL password matches DB_PASSWORD
            echo "Verifying PostgreSQL password..."
            sleep 2  # Give PostgreSQL a moment to fully start
            if docker compose exec -T -e PGPASSWORD="$DB_PASSWORD" postgres psql -U postgres -d postgres -c "SELECT 1;" > /dev/null 2>&1; then
              echo "✅ PostgreSQL password matches DB_PASSWORD"
            else
              echo "❌ CRITICAL: PostgreSQL password does NOT match DB_PASSWORD!"
              echo "   Testing with different passwords to find what works..."
              # Try common passwords
              for TEST_PASS in "postgres" ""; do
                if [ -n "$TEST_PASS" ]; then
                  if docker compose exec -T -e PGPASSWORD="$TEST_PASS" postgres psql -U postgres -d postgres -c "SELECT 1;" > /dev/null 2>&1; then
                    echo "   ⚠️  Database password is actually: $TEST_PASS"
                    echo "   This means POSTGRES_PASSWORD was not set correctly during initialization"
                    break
                  fi
                fi
              done
              echo "   DB_PASSWORD length: ${#DB_PASSWORD} characters"
              docker compose logs postgres --tail=50 | grep -i password || echo "No password-related logs"
              exit 1
            fi
            
            # Start API service with .env file
            echo "Starting API service with .env file..."
            # Ensure .env file exists
            if [ ! -f .env ]; then
              echo "❌ ERROR: .env file not found!"
              exit 1
            fi
            
            # Verify docker-compose can read DB_PASSWORD from .env
            echo "Verifying docker-compose variable substitution..."
            COMPOSE_CONFIG=$(docker compose --env-file .env config 2>&1)
            if echo "$COMPOSE_CONFIG" | grep -q "Password=$DB_PASSWORD"; then
              echo "✅ Variable substitution working - password found in config"
            else
              echo "⚠️  Warning: Could not verify password in docker-compose config"
              echo "   This might still work, but checking..."
            fi
            
            # Use --env-file to explicitly load .env file
            docker compose --env-file .env up -d --no-deps --build api
            
            # Verify connection string in API container and test actual connection
            sleep 5  # Give API more time to start
            echo "Verifying connection string in API container..."
            API_CONN_STR=$(docker compose exec -T api printenv ConnectionStrings__DefaultConnection 2>/dev/null || echo "")
            if [ -n "$API_CONN_STR" ]; then
              # Extract password from connection string
              CONN_PASSWORD=$(echo "$API_CONN_STR" | sed -n 's/.*Password=\([^;]*\).*/\1/p')
              if [ "$CONN_PASSWORD" = "$DB_PASSWORD" ]; then
                echo "✅ Connection string in API container has correct password"
                echo "   Password length: ${#CONN_PASSWORD} characters"
              else
                echo "❌ CRITICAL: Connection string password does NOT match!"
                echo "   Connection string password: ${CONN_PASSWORD:0:5}*** (length: ${#CONN_PASSWORD})"
                echo "   DB_PASSWORD: ${DB_PASSWORD:0:5}*** (length: ${#DB_PASSWORD})"
                echo "   Full connection string: $API_CONN_STR"
                exit 1
              fi
            else
              echo "❌ CRITICAL: Connection string not found in API container environment!"
              echo "   API may be using appsettings.json instead"
              echo "   Checking what connection string API is actually using..."
              docker compose exec -T api cat appsettings.json 2>/dev/null | grep -A 3 ConnectionStrings || echo "Could not read appsettings.json"
              exit 1
            fi
            
            # Test actual connection from API container to PostgreSQL
            echo "Testing database connection from API container perspective..."
            # Try to connect using the same method the API uses
            TEST_RESULT=$(docker compose exec -T api sh -c "export PGPASSWORD='$DB_PASSWORD' && timeout 3 psql -h postgres -U postgres -d smhfr_db -c 'SELECT 1;' 2>&1" || echo "FAILED")
            if echo "$TEST_RESULT" | grep -q "SELECT 1"; then
              echo "✅ Direct connection test from API container succeeded"
            else
              echo "⚠️  Direct connection test failed (psql may not be installed in API container)"
              echo "   Test result: $TEST_RESULT"
            fi
            
            # Check container status first
            echo "=== Container Status ==="
            docker compose ps
            
            # Wait for API to be healthy
            echo "Waiting for API to be healthy..."
            sleep 10
            for i in {1..30}; do
              if curl -f http://localhost:8080/api/health > /dev/null 2>&1; then
                echo "✅ API is healthy"
                break
              fi
              if [ $i -eq 30 ]; then
                echo "❌ API health check failed"
                docker compose logs api --tail=100
                exit 1
              fi
              sleep 2
            done
            
            # Remove old/stopped containers
            docker container prune -f
            
            # Verify deployment
            echo "Verifying deployment..."
            docker compose ps
            curl -f http://localhost:8080/api/health && echo "✅ Deployment successful!"
            
            # Clean up old images
            docker image prune -f
