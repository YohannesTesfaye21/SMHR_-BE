name: Deploy

on:
  workflow_run:
    workflows: ["CI - Build and Test"]
    branches:
      - main
      - master
    types:
      - completed
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    timeout-minutes: 15

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.0.0
        env:
          DB_PASSWORD_SECRET: ${{ secrets.DB_PASSWORD }}
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          envs: DB_PASSWORD_SECRET
          script: |
            set -eo pipefail
            APP_DIR="/opt/smhfr-be"
            REPO_URL="${{ github.repositoryUrl }}"
            
            # Helper function for error logging
            log_error() {
              echo "❌ ERROR: $1" >&2
              exit 1
            }
            
            log_info() {
              echo "ℹ️  $1"
            }
            
            log_success() {
              echo "✅ $1"
            }
            
            # Ensure Docker is installed
            if ! command -v docker &> /dev/null; then
              log_info "Installing Docker..."
              curl -fsSL https://get.docker.com | sh
              systemctl enable docker
              systemctl start docker
            fi
            
            # Ensure docker-compose is available
            if ! command -v docker-compose &> /dev/null && ! docker compose version &> /dev/null; then
              log_info "Installing docker-compose..."
              apt-get update && apt-get install -y docker-compose-plugin
            fi
            
            # Use 'docker compose' if available, fallback to 'docker-compose'
            COMPOSE_CMD="docker compose"
            if ! $COMPOSE_CMD version &> /dev/null; then
              COMPOSE_CMD="docker-compose"
            fi
            
            # Ensure Git is installed
            command -v git &> /dev/null || (apt-get update && apt-get install -y git)
            
            # Create application directory
            mkdir -p "$APP_DIR"
            cd "$APP_DIR" || log_error "Failed to change to $APP_DIR"
            
            # Get DB_PASSWORD from environment variable passed from GitHub secrets FIRST
            # This must be done before git reset to preserve it
            DB_PASSWORD="${DB_PASSWORD_SECRET:-}"
            if [ -z "$DB_PASSWORD" ]; then
              log_error "DB_PASSWORD_SECRET not provided! Please set DB_PASSWORD in GitHub secrets."
            fi
            
            # Create/update .env file BEFORE git reset to ensure it persists
            # .env is in .gitignore, so git reset won't delete it, but we recreate it anyway
            log_info "Creating/updating .env file from GitHub secrets (before git reset)..."
            {
              echo "DB_PASSWORD=${DB_PASSWORD}"
              echo "CONNECTION_STRING=Host=postgres;Port=5432;Database=smhfr_db;Username=postgres;Password=${DB_PASSWORD};Pooling=true;SSL Mode=Disable"
            } > .env
            chmod 600 .env  # Secure the file
            log_success ".env file created/updated with DB_PASSWORD from GitHub secrets"
            
            # Clone or update repository (AFTER .env is created)
            if [ -d ".git" ]; then
              log_info "Updating repository..."
              git fetch origin
              git reset --hard origin/main || git reset --hard origin/master
            else
              log_info "Cloning repository..."
              git clone "$REPO_URL" . || log_error "Failed to clone repository"
            fi
            
            # Verify .env file still exists after git reset (it should, since it's in .gitignore)
            if [ ! -f ".env" ]; then
              log_error ".env file missing after git reset! Recreating..."
              {
                echo "DB_PASSWORD=${DB_PASSWORD}"
                echo "CONNECTION_STRING=Host=postgres;Port=5432;Database=smhfr_db;Username=postgres;Password=${DB_PASSWORD};Pooling=true;SSL Mode=Disable"
              } > .env
              chmod 600 .env
            fi
            
            # Verify docker-compose.yml exists
            if [ ! -f "docker-compose.yml" ]; then
              log_error "docker-compose.yml not found!"
            fi
            
            # Build Docker image with cache
            log_info "Building Docker image..."
            $COMPOSE_CMD build api || log_error "Docker build failed"
            
            # Stop containers
            log_info "Stopping containers..."
            $COMPOSE_CMD down 2>/dev/null || true
            
            # Start PostgreSQL with .env (password comes from .env file)
            log_info "Starting PostgreSQL..."
            $COMPOSE_CMD --env-file .env up -d postgres || log_error "Failed to start PostgreSQL"
            
            # Wait for PostgreSQL to be ready
            log_info "Waiting for PostgreSQL to be ready..."
            MAX_RETRIES=30
            RETRY_COUNT=0
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if $COMPOSE_CMD exec -T postgres pg_isready -U postgres > /dev/null 2>&1; then
                log_success "PostgreSQL is ready"
                break
              fi
              RETRY_COUNT=$((RETRY_COUNT + 1))
              sleep 2
            done
            
            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
              echo "PostgreSQL logs:"
              $COMPOSE_CMD logs postgres --tail=50
              log_error "PostgreSQL failed to start within timeout"
            fi
            
            # Verify password matches - remove volume if not
            sleep 2
            log_info "Testing PostgreSQL connection with provided password..."
            if ! $COMPOSE_CMD exec -T -e PGPASSWORD="$DB_PASSWORD" postgres psql -U postgres -d postgres -c "SELECT 1;" > /dev/null 2>&1; then
              log_info "Password mismatch detected. Recreating PostgreSQL with correct password..."
              log_info "This will remove all existing data and recreate the database with the correct password."
              $COMPOSE_CMD down -v
              $COMPOSE_CMD --env-file .env up -d postgres
              sleep 5
              for i in {1..30}; do
                if $COMPOSE_CMD exec -T postgres pg_isready -U postgres > /dev/null 2>&1; then
                  log_success "PostgreSQL recreated with correct password"
                  break
                fi
                sleep 2
              done
            else
              log_success "PostgreSQL password verification successful"
            fi
            
            # Verify that smhfr_db database exists (it should be created by POSTGRES_DB in docker-compose)
            log_info "Verifying smhfr_db database exists..."
            if ! $COMPOSE_CMD exec -T -e PGPASSWORD="$DB_PASSWORD" postgres psql -U postgres -d smhfr_db -c "SELECT 1;" > /dev/null 2>&1; then
              log_info "Database smhfr_db not found. Creating it..."
              if $COMPOSE_CMD exec -T -e PGPASSWORD="$DB_PASSWORD" postgres psql -U postgres -c "CREATE DATABASE smhfr_db;" > /dev/null 2>&1; then
                log_success "Database smhfr_db created"
              else
                log_error "Failed to create smhfr_db database. This might indicate a password issue."
                log_info "Checking if we can connect to postgres database..."
                if $COMPOSE_CMD exec -T -e PGPASSWORD="$DB_PASSWORD" postgres psql -U postgres -d postgres -c "SELECT current_user;" 2>&1; then
                  log_info "Connection to postgres database works, but smhfr_db creation failed"
                else
                  log_error "Cannot connect to PostgreSQL at all. Password mismatch confirmed."
                fi
                exit 1
              fi
            else
              log_success "Database smhfr_db exists and is accessible"
            fi
            
            # Test the exact connection string that the API will use
            log_info "Testing connection string that API will use..."
            ENV_CONN_STR=$(grep "^CONNECTION_STRING=" .env | cut -d'=' -f2- || echo "")
            if [ -n "$ENV_CONN_STR" ]; then
              # Extract connection details for testing
              DB_HOST=$(echo "$ENV_CONN_STR" | sed 's/.*Host=\([^;]*\).*/\1/' || echo "")
              DB_PORT=$(echo "$ENV_CONN_STR" | sed 's/.*Port=\([^;]*\).*/\1/' || echo "")
              DB_NAME=$(echo "$ENV_CONN_STR" | sed 's/.*Database=\([^;]*\).*/\1/' || echo "")
              DB_USER=$(echo "$ENV_CONN_STR" | sed 's/.*Username=\([^;]*\).*/\1/' || echo "")
              DB_PASS=$(echo "$ENV_CONN_STR" | sed 's/.*Password=\([^;]*\).*/\1/' || echo "")
              
              log_info "Connection string details: Host=$DB_HOST, Port=$DB_PORT, Database=$DB_NAME, Username=$DB_USER"
              
              # Test connection - since we're testing from within the postgres container,
              # we need to connect to localhost instead of the service name
              if [ "$DB_HOST" = "postgres" ]; then
                TEST_HOST="localhost"
              else
                TEST_HOST="$DB_HOST"
              fi
              
              log_info "Testing connection to $TEST_HOST:$DB_PORT/$DB_NAME as $DB_USER..."
              if $COMPOSE_CMD exec -T -e PGPASSWORD="$DB_PASS" postgres psql -h "$TEST_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -c "SELECT 1;" > /dev/null 2>&1; then
                log_success "API connection string test successful"
              else
                log_error "API connection string test failed!"
                log_error "The API will not be able to connect to the database with this connection string."
                log_error "Connection details: Host=$DB_HOST, Port=$DB_PORT, Database=$DB_NAME, Username=$DB_USER"
                
                # Additional debugging
                log_info "Attempting to diagnose the issue..."
                log_info "Testing direct connection to smhfr_db..."
                if $COMPOSE_CMD exec -T -e PGPASSWORD="$DB_PASS" postgres psql -U "$DB_USER" -d "$DB_NAME" -c "SELECT current_user, current_database();" 2>&1; then
                  log_info "Direct connection works, issue might be with host resolution"
                else
                  log_error "Direct connection also fails. Password or user issue confirmed."
                fi
                exit 1
              fi
            else
              log_error "CONNECTION_STRING not found in .env file for testing"
            fi
            
            # Verify .env CONNECTION_STRING contains correct password and database name before starting API
            log_info "Verifying CONNECTION_STRING in .env file..."
            ENV_CONN_STR=$(grep "^CONNECTION_STRING=" .env | cut -d'=' -f2- || echo "")
            if [ -z "$ENV_CONN_STR" ]; then
              log_error "CONNECTION_STRING not found in .env file!"
            fi
            
            # Verify database name is smhfr_db (not postgres)
            ENV_CONN_DB=$(echo "$ENV_CONN_STR" | sed 's/.*Database=\([^;]*\).*/\1/' || echo "")
            if [ "$ENV_CONN_DB" != "smhfr_db" ]; then
              log_error ".env CONNECTION_STRING has wrong database name: '$ENV_CONN_DB' (expected: 'smhfr_db')!"
              log_error "This will cause connection failures. Please ensure Database=smhfr_db in connection string."
            fi
            log_success ".env CONNECTION_STRING database name verified: $ENV_CONN_DB"
            
            # Verify password matches
            ENV_CONN_PASS=$(echo "$ENV_CONN_STR" | sed 's/.*Password=\([^;]*\).*/\1/' || echo "")
            if [ "$ENV_CONN_PASS" != "$DB_PASSWORD" ]; then
              log_error ".env CONNECTION_STRING password ($ENV_CONN_PASS) doesn't match DB_PASSWORD!"
            fi
            log_success ".env CONNECTION_STRING password verified"
            
            # Remove API container to ensure fresh start with correct environment variables
            log_info "Removing API container to ensure fresh environment..."
            $COMPOSE_CMD rm -f api 2>/dev/null || true
            
            # Show environment variables that will be passed to API
            log_info "Environment variables for API container:"
            echo "DB_PASSWORD=${DB_PASSWORD:0:3}***"
            echo "CONNECTION_STRING=$(echo "$ENV_CONN_STR" | sed 's/Password=[^;]*/Password=***/')"
            
            # Start API service with fresh container and correct .env
            log_info "Starting API service with .env file..."
            $COMPOSE_CMD --env-file .env up -d --no-deps --force-recreate api || log_error "Failed to start API service"
            
            # Wait for API container to be running before checking environment
            log_info "Waiting for API container to start..."
            sleep 10
            MAX_WAIT=20
            WAIT_COUNT=0
            while [ $WAIT_COUNT -lt $MAX_WAIT ]; do
              CONTAINER_STATE=$($COMPOSE_CMD ps api --format json 2>/dev/null | grep -o '"State":"[^"]*"' | cut -d'"' -f4 || echo "unknown")
              if [ "$CONTAINER_STATE" = "running" ]; then
                log_success "API container is running"
                break
              fi
              WAIT_COUNT=$((WAIT_COUNT + 1))
              sleep 1
            done
            
            # Verify API container has correct connection string environment variable
            log_info "Verifying API container connection string environment variable..."
            CONTAINER_STATE=$($COMPOSE_CMD ps api --format json 2>/dev/null | grep -o '"State":"[^"]*"' | cut -d'"' -f4 || echo "unknown")
            
            if [ "$CONTAINER_STATE" = "running" ]; then
              # Get the connection string from the API container
              API_CONN_STR=$($COMPOSE_CMD exec -T api printenv ConnectionStrings__DefaultConnection 2>/dev/null || echo "")
              
              if [ -z "$API_CONN_STR" ]; then
                log_error "❌ ConnectionStrings__DefaultConnection not set in API container environment!"
                log_info "Checking all environment variables in API container..."
                $COMPOSE_CMD exec -T api printenv | grep -i connection || log_info "No connection-related env vars found"
                log_info "Checking .env file contents..."
                cat .env | sed 's/Password=[^;]*/Password=***/' || log_info "Could not read .env file"
              else
                log_info "✅ Connection string found in API container"
                
                # Extract and verify components
                API_CONN_DB=$(echo "$API_CONN_STR" | sed -n 's/.*Database=\([^;]*\).*/\1/p' || echo "")
                API_CONN_USER=$(echo "$API_CONN_STR" | sed -n 's/.*Username=\([^;]*\).*/\1/p' || echo "")
                API_CONN_HOST=$(echo "$API_CONN_STR" | sed -n 's/.*Host=\([^;]*\).*/\1/p' || echo "")
                API_CONN_PASS=$(echo "$API_CONN_STR" | sed -n 's/.*Password=\([^;]*\).*/\1/p' || echo "")
                
                log_info "API Connection Details:"
                log_info "  Host: $API_CONN_HOST"
                log_info "  Database: $API_CONN_DB"
                log_info "  Username: $API_CONN_USER"
                log_info "  Password: ${API_CONN_PASS:0:3}*** (length: ${#API_CONN_PASS})"
                
                # Verify database name
                if [ "$API_CONN_DB" != "smhfr_db" ]; then
                  log_error "❌ API container has wrong database name: '$API_CONN_DB' (expected: 'smhfr_db')!"
                else
                  log_success "✅ Database name correct: $API_CONN_DB"
                fi
                
                # Verify password matches
                if [ "$API_CONN_PASS" != "$DB_PASSWORD" ]; then
                  log_error "❌ API container password doesn't match DB_PASSWORD!"
                  log_error "  Expected password length: ${#DB_PASSWORD}"
                  log_error "  Actual password length: ${#API_CONN_PASS}"
                  log_error "  Expected starts with: ${DB_PASSWORD:0:5}***"
                  log_error "  Actual starts with: ${API_CONN_PASS:0:5}***"
                else
                  log_success "✅ Password matches"
                fi
              fi
            else
              log_info "⚠️  API container state: $CONTAINER_STATE (not running yet)"
              log_info "Container logs:"
              $COMPOSE_CMD logs api --tail=20
            fi
            
            # Wait for API to be healthy
            log_info "Waiting for API to be healthy..."
            MAX_RETRIES=90
            RETRY_COUNT=0
            sleep 10  # Give API initial startup time
            
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              # Check if container is still running
              CONTAINER_STATUS=$($COMPOSE_CMD ps api --format json 2>/dev/null | grep -o '"State":"[^"]*"' | cut -d'"' -f4 || echo "unknown")
              
              if [ "$CONTAINER_STATUS" = "exited" ] || [ "$CONTAINER_STATUS" = "dead" ]; then
                echo "Container status: $CONTAINER_STATUS"
                echo "=== API Logs (last 100 lines) ==="
                $COMPOSE_CMD logs api --tail=100
                log_error "API container stopped unexpectedly"
              fi
              
              # Check health endpoint
              if curl -f http://localhost:8080/api/health > /dev/null 2>&1; then
                log_success "API is healthy"
                break
              fi
              
              RETRY_COUNT=$((RETRY_COUNT + 1))
              
              # Show progress every 15 attempts
              if [ $((RETRY_COUNT % 15)) -eq 0 ]; then
                log_info "Still waiting... (attempt $RETRY_COUNT/$MAX_RETRIES)"
                $COMPOSE_CMD logs api --tail=10
              fi
              
              sleep 2
            done
            
            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
              echo "=== API Logs (last 150 lines) ==="
              $COMPOSE_CMD logs api --tail=150
              echo "=== Container Status ==="
              $COMPOSE_CMD ps
              log_error "API health check failed after timeout"
            fi
            
            log_success "Deployment successful!"
