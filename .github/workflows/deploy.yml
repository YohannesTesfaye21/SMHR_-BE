name: Deploy

on:
  workflow_run:
    workflows: ["CI - Build and Test"]
    branches:
      - main
      - master
    types:
      - completed
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    timeout-minutes: 15

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            set -euo pipefail
            
            APP_DIR="/opt/smhfr-be"
            REPO_URL="${{ github.repositoryUrl }}"
            
            # Helper function for error logging
            log_error() {
              echo "❌ ERROR: $1" >&2
              exit 1
            }
            
            log_info() {
              echo "ℹ️  $1"
            }
            
            log_success() {
              echo "✅ $1"
            }
            
            # Ensure Docker is installed
            if ! command -v docker &> /dev/null; then
              log_info "Installing Docker..."
              curl -fsSL https://get.docker.com | sh
              systemctl enable docker
              systemctl start docker
            fi
            
            # Ensure docker-compose is available
            if ! command -v docker-compose &> /dev/null && ! docker compose version &> /dev/null; then
              log_info "Installing docker-compose..."
              apt-get update && apt-get install -y docker-compose-plugin
            fi
            
            # Use 'docker compose' if available, fallback to 'docker-compose'
            COMPOSE_CMD="docker compose"
            if ! $COMPOSE_CMD version &> /dev/null; then
              COMPOSE_CMD="docker-compose"
            fi
            
            # Ensure Git is installed
            command -v git &> /dev/null || (apt-get update && apt-get install -y git)
            
            # Create application directory
            mkdir -p "$APP_DIR"
            cd "$APP_DIR" || log_error "Failed to change to $APP_DIR"
            
            # Clone or update repository
            if [ -d ".git" ]; then
              log_info "Updating repository..."
              git fetch origin
              git reset --hard origin/main || git reset --hard origin/master
            else
              log_info "Cloning repository..."
              git clone "$REPO_URL" . || log_error "Failed to clone repository"
            fi
            
            # Verify docker-compose.yml exists
            if [ ! -f "docker-compose.yml" ]; then
              log_error "docker-compose.yml not found!"
            fi
            
            # Check .env file exists and contains required variables
            if [ ! -f ".env" ]; then
              log_error ".env file not found! Please create it with DB_PASSWORD and CONNECTION_STRING variables."
            fi
            
            # Verify required variables are present
            if ! grep -q "DB_PASSWORD=" .env || ! grep -q "CONNECTION_STRING=" .env; then
              log_error ".env file is missing required variables (DB_PASSWORD and/or CONNECTION_STRING)"
            fi
            
            log_success ".env file validated"
            
            # Extract DB_PASSWORD from .env file safely (without sourcing)
            # This is only needed for password verification step
            # The .env file on the server is used as-is by docker compose
            DB_PASSWORD=$(grep "^DB_PASSWORD=" .env | cut -d'=' -f2- | tr -d '\r\n' || echo "")
            if [ -z "$DB_PASSWORD" ]; then
              log_error "Failed to extract DB_PASSWORD from .env file"
            fi
            
            log_info "Using existing .env file from server (will not modify it)"
            
            # Build Docker image with cache
            log_info "Building Docker image..."
            $COMPOSE_CMD build api || log_error "Docker build failed"
            
            # Stop existing containers
            log_info "Stopping existing containers..."
            $COMPOSE_CMD down 2>/dev/null || true
            
            # Start PostgreSQL with health check
            log_info "Starting PostgreSQL..."
            $COMPOSE_CMD --env-file .env up -d postgres || log_error "Failed to start PostgreSQL"
            
            # Wait for PostgreSQL to be ready
            log_info "Waiting for PostgreSQL to be ready..."
            MAX_RETRIES=30
            RETRY_COUNT=0
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              if $COMPOSE_CMD exec -T postgres pg_isready -U postgres > /dev/null 2>&1; then
                log_success "PostgreSQL is ready"
                break
              fi
              RETRY_COUNT=$((RETRY_COUNT + 1))
              sleep 2
            done
            
            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
              echo "PostgreSQL logs:"
              $COMPOSE_CMD logs postgres --tail=50
              log_error "PostgreSQL failed to start within timeout"
            fi
            
            # Verify PostgreSQL connection with password from .env
            log_info "Verifying PostgreSQL password..."
            sleep 2
            if ! $COMPOSE_CMD exec -T -e PGPASSWORD="$DB_PASSWORD" postgres psql -U postgres -d postgres -c "SELECT 1;" > /dev/null 2>&1; then
              log_error "PostgreSQL password verification failed. Check DB_PASSWORD in .env file."
            fi
            log_success "PostgreSQL password verified"
            
            # Update CONNECTION_STRING password to match DB_PASSWORD
            log_info "Updating CONNECTION_STRING password to match DB_PASSWORD..."
            # Escape special characters in DB_PASSWORD for sed
            ESCAPED_PASSWORD=$(printf '%s\n' "$DB_PASSWORD" | sed 's/[[\.*^$()+?{|]/\\&/g')
            # Update Password=... in CONNECTION_STRING
            sed -i.tmp "s/Password=[^;]*/Password=${ESCAPED_PASSWORD}/" .env
            rm -f .env.tmp
            log_success "CONNECTION_STRING password updated"
            
            # Start API service
            log_info "Starting API service..."
            $COMPOSE_CMD --env-file .env up -d --no-deps api || log_error "Failed to start API service"
            
            # Wait for API to be healthy
            log_info "Waiting for API to be healthy..."
            MAX_RETRIES=90
            RETRY_COUNT=0
            sleep 10  # Give API initial startup time
            
            while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
              # Check if container is still running
              CONTAINER_STATUS=$($COMPOSE_CMD ps api --format json 2>/dev/null | grep -o '"State":"[^"]*"' | cut -d'"' -f4 || echo "unknown")
              
              if [ "$CONTAINER_STATUS" = "exited" ] || [ "$CONTAINER_STATUS" = "dead" ]; then
                echo "Container status: $CONTAINER_STATUS"
                echo "=== API Logs (last 100 lines) ==="
                $COMPOSE_CMD logs api --tail=100
                log_error "API container stopped unexpectedly"
              fi
              
              # Check health endpoint
              if curl -f http://localhost:8080/api/health > /dev/null 2>&1; then
                log_success "API is healthy"
                break
              fi
              
              RETRY_COUNT=$((RETRY_COUNT + 1))
              
              # Show progress every 15 attempts
              if [ $((RETRY_COUNT % 15)) -eq 0 ]; then
                log_info "Still waiting... (attempt $RETRY_COUNT/$MAX_RETRIES)"
                $COMPOSE_CMD logs api --tail=10
              fi
              
              sleep 2
            done
            
            if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
              echo "=== API Logs (last 150 lines) ==="
              $COMPOSE_CMD logs api --tail=150
              echo "=== Container Status ==="
              $COMPOSE_CMD ps
              log_error "API health check failed after timeout"
            fi
            
            # Cleanup and verify
            log_info "Cleaning up..."
            docker container prune -f
            docker image prune -f
            
            # Final verification
            log_info "Verifying deployment..."
            $COMPOSE_CMD ps
            
            if curl -f http://localhost:8080/api/health > /dev/null 2>&1; then
              log_success "Deployment successful!"
            else
              log_error "Deployment verification failed"
            fi
