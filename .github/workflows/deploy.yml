name: Deploy

on:
  workflow_run:
    workflows: ["CI - Build and Test"]
    types:
      - completed
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 3
    if: github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Copy files to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          source: "."
          target: "/opt/smhfr-be"
          overwrite: true
          rm: false
          strip_components: 0
          exclude: |
            .git
            .github
            **/bin
            **/obj
            **/.vs
            **/.vscode
            *.md
            SERVER_FAILURE_ANALYSIS.md

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          script: |
            cd /opt/smhfr-be
            export COMPOSE_PROJECT_NAME=smhfr-be
            
            # Create .env file
            cat > .env <<EOF
            DB_HOST=postgres
            DB_PORT=5432
            DB_NAME=smhfr_db
            DB_USER=postgres
            DB_PASSWORD=${{ secrets.DB_PASSWORD }}
            EOF
            
            # Ensure entrypoint script is executable
            chmod +x docker-entrypoint-postgres.sh
            
            # Stop and recreate postgres to ensure entrypoint script runs
            echo "üîÑ Restarting Postgres to trigger entrypoint script..."
            docker compose --env-file .env stop postgres 2>/dev/null || true
            docker compose --env-file .env up -d postgres
            
            # Wait for Postgres to be ready (entrypoint script will sync password)
            echo "‚è≥ Waiting for Postgres and password sync..."
            for i in {1..30}; do
              if docker compose exec -T postgres pg_isready -U postgres > /dev/null 2>&1; then
                echo "‚úÖ Postgres is ready"
                # Check if entrypoint script has synced password by checking logs
                if docker compose logs postgres 2>/dev/null | grep -q "Password synchronized successfully\|Current password already matches"; then
                  echo "‚úÖ Password sync confirmed from entrypoint script"
                  break
                elif [ $i -ge 10 ]; then
                  # After 10 seconds, try to verify password anyway
                  echo "‚è≥ Entrypoint script may still be syncing, verifying password..."
                  break
                fi
              fi
              sleep 1
            done
            
            # Wait a bit more for entrypoint script to complete
            sleep 3
            
            # Verify password works (entrypoint script should have synced it)
            echo "üîç Verifying password after entrypoint sync..."
            PGPASSWORD='${{ secrets.DB_PASSWORD }}' docker compose exec -T -e PGPASSWORD='${{ secrets.DB_PASSWORD }}' postgres psql -h localhost -U postgres -d postgres -c "SELECT 1;" > /dev/null 2>&1
            if [ $? -ne 0 ]; then
              echo "‚ö†Ô∏è  Password verification failed, checking entrypoint script logs..."
              docker compose logs postgres | tail -20
              echo "üîÑ Attempting manual password sync as fallback..."
              docker compose exec -T postgres psql -U postgres -d postgres -c "ALTER USER postgres WITH PASSWORD '${{ secrets.DB_PASSWORD }}';" || true
              sleep 2
              # Verify again
              PGPASSWORD='${{ secrets.DB_PASSWORD }}' docker compose exec -T -e PGPASSWORD='${{ secrets.DB_PASSWORD }}' postgres psql -h localhost -U postgres -d postgres -c "SELECT 1;" > /dev/null 2>&1
              if [ $? -ne 0 ]; then
                echo "‚ùå Password verification failed even after manual sync"
                exit 1
              fi
            fi
            echo "‚úÖ Password verified"
            
            # Run database migrations before starting API
            echo "üîÑ Running database migrations..."
            # Use a temporary container to run migrations
            docker compose --env-file .env run --rm --no-deps api dotnet ef database update || {
              echo "‚ùå Migration failed!"
              echo "üìã Checking migration status..."
              docker compose exec -T postgres psql -U postgres -d smhfr_db -c "\dt" || true
              exit 1
            }
            echo "‚úÖ Migrations completed successfully"
            
            # Stop API
            docker compose stop api 2>/dev/null || true
            
            # Remove persisted connection string volume
            docker volume rm smhfr-be_api_data 2>/dev/null || true
            
            # Start API
            echo "üöÄ Starting API..."
            docker compose --env-file .env up -d --build --no-deps api
            
            # Wait for API container to be running and accessible (max 60 seconds)
            echo "‚è≥ Waiting for API to start and become accessible..."
            for i in {1..30}; do
              if docker compose ps api | grep -q "Up"; then
                echo "‚úÖ API container is running"
                # Give it a moment to initialize
                sleep 5
                # Check if it's still running (didn't crash)
                if docker compose ps api | grep -q "Up"; then
                  # Try to access the health endpoint
                  echo "üîç Testing API accessibility..."
                  if curl -f -s http://localhost:8080/api/health > /dev/null 2>&1; then
                    echo "‚úÖ API is accessible via HTTP"
                    # Try Swagger endpoint
                    if curl -f -s http://localhost:8080/swagger/index.html > /dev/null 2>&1; then
                      echo "‚úÖ Swagger UI is accessible"
                    else
                      echo "‚ö†Ô∏è  Swagger UI not accessible, but API is running"
                    fi
                    echo "‚úÖ Deployment successful"
                    # Check HTTPS configuration
                    echo "üîç Checking HTTPS configuration..."
                    docker compose logs api | grep -E "(HTTPS|Certificate|cert|Listening)" | tail -10 || echo "No HTTPS logs found"
                    # Show recent logs
                    echo "üìã Recent API logs:"
                    docker compose logs api --tail=20
                    exit 0
                  else
                    echo "‚ö†Ô∏è  API container is running but not responding (attempt $i/30)"
                    if [ $i -ge 10 ]; then
                      echo "üìã API logs:"
                      docker compose logs api --tail=30
                    fi
                  fi
                else
                  echo "‚ùå API container crashed after startup"
                  docker compose logs api --tail=50
                  exit 1
                fi
              fi
              echo "‚è≥ Waiting for API... (attempt $i/30)"
              sleep 2
            done
            
            # Final check
            if docker compose ps api | grep -q "Up"; then
              echo "‚ö†Ô∏è  API container is running but not accessible after 60 seconds"
              echo "üìã Checking logs and container status:"
              docker compose ps api
              docker compose logs api --tail=50
              echo "üîç Testing connectivity:"
              curl -v http://localhost:8080/api/health || echo "Connection failed"
              exit 1
            else
              echo "‚ùå API not running after 60 seconds"
              docker compose logs api --tail=50
              exit 1
            fi
