name: Deploy

on:
  workflow_run:
    workflows: ["CI - Build and Test"]
    branches:
      - main
      - master
    types:
      - completed
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.0.0
        env:
          DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          envs: DB_PASSWORD
          script: |
            set -e
            
            APP_DIR="/opt/smhfr-be"
            REPO_URL="https://github.com/YohannesTesfaye21/SMHR_-BE.git"
            
            # Ensure Docker is installed
            if ! command -v docker &> /dev/null; then
              echo "Installing Docker..."
              curl -fsSL https://get.docker.com | sh
              systemctl enable docker
              systemctl start docker
            fi
            
            # Ensure Git is installed
            command -v git &> /dev/null || (apt-get update && apt-get install -y git)
            
            # Create application directory
            mkdir -p "$APP_DIR"
            cd "$APP_DIR"
            
            # Clone or update repository
            if [ -d ".git" ]; then
              echo "Pulling latest changes..."
              git fetch origin
              git reset --hard origin/main
            else
              echo "Cloning repository..."
              git clone "$REPO_URL" .
            fi
            
            # Ensure docker-compose.yml exists
            if [ ! -f "docker-compose.yml" ]; then
              echo "Error: docker-compose.yml not found!"
              exit 1
            fi
            
            # Set database password from GitHub secret (REQUIRED - no default)
            if [ -z "$DB_PASSWORD" ]; then
              echo "❌ ERROR: DB_PASSWORD environment variable is not set!"
              echo "Please set DB_PASSWORD in GitHub secrets"
              exit 1
            fi
            echo "Using DB_PASSWORD from environment (from GitHub secret)"
            echo "DB_PASSWORD value is set (length: ${#DB_PASSWORD} characters)"
            
            # Create .env file - MUST be in same directory as docker-compose.yml
            # Docker Compose automatically reads .env file from current directory
            echo "DB_PASSWORD=$DB_PASSWORD" > .env
            echo "✅ Created .env file"
            echo "Current directory: $(pwd)"
            echo ".env file location: $(pwd)/.env"
            echo ".env file exists: $([ -f .env ] && echo 'yes' || echo 'no')"
            echo ".env file contents (password hidden): $(cat .env | sed 's/DB_PASSWORD=.*/DB_PASSWORD=***/')"
            
            # Also export to environment for docker-compose variable substitution
            export DB_PASSWORD
            echo "✅ Exported DB_PASSWORD to environment (length: ${#DB_PASSWORD} characters)"
            
            # Build new image
            echo "Building Docker image..."
            docker compose build --no-cache api
            
            # Start PostgreSQL (reads .env file for POSTGRES_PASSWORD=${DB_PASSWORD})
            echo "Starting PostgreSQL with .env file..."
            # DB_PASSWORD is already exported above
            docker compose --env-file .env up -d postgres
            
            # Wait for PostgreSQL to be healthy
            echo "Waiting for PostgreSQL to be ready..."
            sleep 5
            for i in {1..30}; do
              STATUS=$(docker compose ps postgres --format json 2>/dev/null | grep -o '"State":"[^"]*"' | cut -d'"' -f4 || echo "")
              if echo "$STATUS" | grep -q "running\|healthy"; then
                echo "✅ PostgreSQL is running"
                break
              fi
              if [ $i -eq 30 ]; then
                echo "❌ PostgreSQL failed to start - checking logs..."
                docker compose logs postgres --tail=50
                echo "PostgreSQL container status:"
                docker ps -a | grep postgres || echo "Container not found"
                exit 1
              fi
              sleep 2
            done
            
            # Reset PostgreSQL password to match GitHub secret (handles existing volumes with different password)
            echo "Resetting PostgreSQL password to match GitHub secret..."
            # Try multiple methods to reset password, handling cases where volume has old password
            PASSWORD_RESET=false
            # Method 1: Try with new password (if volume was just created or already has this password)
            if docker compose exec -T -e PGPASSWORD="$DB_PASSWORD" postgres psql -U postgres -d postgres -c "ALTER USER postgres WITH PASSWORD '$DB_PASSWORD';" 2>/dev/null; then
              echo "✅ Password reset using new password"
              PASSWORD_RESET=true
            # Method 2: Try with common default password 'postgres'
            elif docker compose exec -T -e PGPASSWORD="postgres" postgres psql -U postgres -d postgres -c "ALTER USER postgres WITH PASSWORD '$DB_PASSWORD';" 2>/dev/null; then
              echo "✅ Password reset using default 'postgres' password"
              PASSWORD_RESET=true
            # Method 3: Try without password (trust authentication - only works if pg_hba.conf allows it)
            elif docker compose exec -T postgres psql -U postgres -d postgres -c "ALTER USER postgres WITH PASSWORD '$DB_PASSWORD';" 2>/dev/null; then
              echo "✅ Password reset using trust authentication"
              PASSWORD_RESET=true
            fi
            
            if [ "$PASSWORD_RESET" = false ]; then
              echo "⚠️  Could not reset password automatically. The database volume may have been initialized with a different password."
              echo "   Attempting to recreate the database volume..."
              # Stop containers
              docker compose down postgres api 2>/dev/null || true
              # Remove the volume to start fresh
              docker volume rm smhfr-be_postgres_data 2>/dev/null || docker volume rm $(docker volume ls -q | grep postgres_data) 2>/dev/null || echo "Volume not found or already removed"
              # Start PostgreSQL again with the correct password
              echo "Starting PostgreSQL with fresh volume and correct password..."
              docker compose --env-file .env up -d postgres
              # Wait for PostgreSQL to be ready
              sleep 5
              for i in {1..30}; do
                if docker compose exec -T postgres pg_isready -U postgres > /dev/null 2>&1; then
                  echo "✅ PostgreSQL is ready with new password"
                  break
                fi
                if [ $i -eq 30 ]; then
                  echo "❌ PostgreSQL failed to start after volume recreation"
                  docker compose logs postgres --tail=50
                  exit 1
                fi
                sleep 2
              done
            fi
            
            # Verify password was set correctly
            echo "Verifying password reset..."
            if docker compose exec -T -e PGPASSWORD="$DB_PASSWORD" postgres psql -U postgres -d postgres -c "SELECT 1;" > /dev/null 2>&1; then
              echo "✅ Password verification successful"
            else
              echo "❌ Password verification failed. This is a critical error."
              echo "   Connection string password: ${DB_PASSWORD:0:2}*** (hidden)"
              echo "   Database password may not match. Check logs above."
              exit 1
            fi
            sleep 2
            
            # Start API container (uses .env file for ${DB_PASSWORD} in connection string)
            echo "Starting API service..."
            # DB_PASSWORD is already exported above
            
            # Verify .env file is correct before starting
            echo "Verifying .env file before starting API..."
            if [ -f .env ]; then
              echo ".env file exists and contains: $(cat .env | sed 's/DB_PASSWORD=.*/DB_PASSWORD=***/')"
            else
              echo "❌ ERROR: .env file not found!"
              exit 1
            fi
            
            # Verify docker-compose variable substitution works
            echo "Testing docker-compose variable substitution..."
            COMPOSE_CONFIG=$(docker compose --env-file .env config 2>&1)
            if echo "$COMPOSE_CONFIG" | grep -q "Password=$DB_PASSWORD"; then
              echo "✅ Variable substitution verified in docker-compose config"
            elif echo "$COMPOSE_CONFIG" | grep -q "Password=\${DB_PASSWORD}"; then
              echo "❌ ERROR: Variable substitution FAILED - Password still shows \${DB_PASSWORD}"
              echo "   This means docker-compose cannot read DB_PASSWORD from .env file"
              echo "   Checking .env file format..."
              cat .env
              exit 1
            else
              echo "⚠️  Could not verify variable substitution in config, but continuing..."
            fi
            
            docker compose --env-file .env up -d --no-deps --build api
            
            # Wait a bit for container to start
            sleep 5
            
            # Verify the connection string in the API container has the correct password
            echo "Verifying connection string in API container..."
            API_CONN_STR=$(docker compose exec -T api printenv ConnectionStrings__DefaultConnection 2>/dev/null || echo "")
            if [ -n "$API_CONN_STR" ]; then
              # Check if password in connection string matches (extract password from connection string)
              CONN_PASSWORD=$(echo "$API_CONN_STR" | grep -oP 'Password=\K[^;]*' || echo "")
              if [ -n "$CONN_PASSWORD" ]; then
                if [ "$CONN_PASSWORD" = "$DB_PASSWORD" ]; then
                  echo "✅ Connection string password matches DB_PASSWORD"
                else
                  echo "❌ CRITICAL: Connection string password does NOT match DB_PASSWORD!"
                  echo "   Connection string password: ${CONN_PASSWORD:0:2}*** (length: ${#CONN_PASSWORD})"
                  echo "   DB_PASSWORD: ${DB_PASSWORD:0:2}*** (length: ${#DB_PASSWORD})"
                  echo "   This means variable substitution failed!"
                  exit 1
                fi
              else
                echo "⚠️  Could not extract password from connection string"
              fi
            else
              echo "⚠️  Could not read connection string from API container"
            fi
            
            # Check container status first
            echo "=== Container Status ==="
            docker compose ps
            
            # Wait for new API to be healthy
            echo "Waiting for API to be healthy..."
            timeout 60 bash -c 'until curl -f http://localhost:8080/api/health > /dev/null 2>&1; do sleep 2; done' || {
              echo "❌ API health check failed, checking logs..."
              echo "=== Full API Logs (last 150 lines) ==="
              docker compose logs api --tail=150
              echo ""
              echo "=== Checking container status ==="
              docker compose ps
              echo ""
              echo "=== Checking if API can reach PostgreSQL ==="
              docker compose exec api sh -c "timeout 5 sh -c 'until nc -z postgres 5432; do sleep 1; done' && echo 'PostgreSQL port is reachable' || echo 'Cannot reach postgres:5432'" 2>&1 || echo "Network check failed"
              echo ""
              echo "=== Checking API container network ==="
              docker compose exec api cat /etc/hosts | grep postgres || echo "PostgreSQL hostname not in /etc/hosts"
              exit 1
            }
            
            # Remove old/stopped containers
            docker container prune -f
            
            # Verify deployment
            echo "Verifying deployment..."
            docker compose ps
            curl -f http://localhost:8080/api/health && echo "✅ Deployment successful!"
            
            # Clean up old images
            docker image prune -f
